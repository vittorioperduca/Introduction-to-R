[
["index.html", "An Introduction to R Chapter 1 Welcome", " An Introduction to R Vittorio Perduca (Université de Paris) September 2020 Chapter 1 Welcome This document is a tutorial for self-learning the basic use of R. It was prepared for the students enrolled in the first year of the AIRE Life Sciences Master Program of the Centre de Recherche Interdisciplinaire at the Université de Paris. This document was written with the R package bookdown (Xie 2020), (Xie 2016) and is under continuous development, please report any issues to vittorio.perduca at u-paris.fr. This work is licensed under CC BY-NC 4.0. References "],
["introduction.html", "Chapter 2 Introduction 2.1 How to use this document 2.2 Useful references 2.3 Installing R and Rstudio 2.4 Getting started with RStudio 2.5 Packages", " Chapter 2 Introduction R is a statistical language developed from the 1990s at the University of Auckland, New Zealand. Its main implementation is the open source software (free and modifiable) R. R is normally used from the graphical user interface (GUI) and development interface RStudio. R is an interpreted language (likePython) that we use from the command line: print (&#39;Hello world!&#39;) ## [1] &quot;Hello world!&quot; Alternatively, you can run a script, that is a series of commands found in a file with the extension .R. The R user community is very active in the scientific world (statistics, data science, bioinformatics, social sciences, …) and more and more in companies. One of the advantages of R is the wealth of packages developed by users and developers that can be installed to increase its capabilities in many areas of statistics. In addition, R has a very complete documentation. You can access help by typing ? followed by the function you are interested in: ? rnorm You can also find a lot of information on the web: by searching on Google for a problem related to an R task, you almost always find an answer (often in threads opened on Cross Validated). 2.1 How to use this document Although basic objects and commands are covered, this introduction is not a complete reference to the R language, so you will have to use the help and search for information on the web. Before moving on to the exercises at the end of each chapter, you are encouraged to type the commands and understand the result: the best way to learn a language is to write and debug lots of lines of code! 2.2 Useful references A complete reference to R is the official introduction that can be found on the CRAN website: https://cran.r-project.org/doc/manuals/R-intro.html. For French readers, an excellent reference is Vincent Goulet’s book Introduction à la programmation R, which can be downloaded at https://cran.r-project.org/doc/contrib/Goulet_introduction_programmation_R.pdf 2.3 Installing R and Rstudio Download the R distribution that is appropriate for your machine from https://cran.r-project.org/ and install it by double-clicking on the installation file. Dowanload and install RStudio Desktop from https://rstudio.com/products/rstudio/download/. 2.4 Getting started with RStudio The RStudio workspace is generally divided into four pans: starting from the top left and going clockwise we find: a script editor the environment listing the variables in memory and the history of commands that were executed a window for graphical outputs, the help, and the file and package managers. the R console, ie the command line. Typically we type the code in the editor and then run it in the console. To do this we place the cursor in the line we want to execute and we send the command to the console using the combination cmd Return in macOS andctrl Return under Linux and Windows. 2.5 Packages To install a package from the console: install.packages(&quot;dplyr&quot;) # download and install the dplyr package used for data manipulation Once a package is installed, it will have to be loaded into memory each time a new session is opened: library(dplyr) # quotes are not needed here # require(dplyr) # equivalent function "],
["language-basics.html", "Chapter 3 Language basics 3.1 Assignments, arithmetic operations 3.2 Mode, length and class", " Chapter 3 Language basics 3.1 Assignments, arithmetic operations There are two types of R commands: expressions and assignments. Expression cos(pi) ## [1] -1 Assignments and expressions x &lt;- 1 + 2 # or x = 1 + 2 x ## [1] 3 y = 4 x == y ## [1] FALSE Using ; we can type two commands on the same line before executing them: e &lt;- exp (1); log (e) ## [1] 1 Some examples of arithmetic and Boolean operators: 3*4 ## [1] 12 12/3 ## [1] 4 2^3 ## [1] 8 sqrt (16) ## [1] 4 1 == 2 ## [1] FALSE 1!= 1 ## [1] FALSE FALSE &amp; TRUE # and ## [1] FALSE FALSE | TRUE # or ## [1] TRUE 3.2 Mode, length and class In R, everything is an object. The mode specifies what an object can contain. The main modes are: numeric: real numbers character: character strings logical: logical values true / false list: list, collection of objects function: function numeric,character, and logical objects are simple objects that can contain data of only one type. On the contrary, list mobjects are special objects that can contain other objects. You can access the mode of an object with the mode () function: age = c(33,28, 33) # The concatenation function c() allows to create vectors mode(age) ## [1] &quot;numeric&quot; names &lt;- c(&#39;Daniel&#39;, &#39;Jehanne&#39;, &#39;Romain&#39;) mode(names) ## [1] &quot;character&quot; my.list &lt;- list(Names = names, Age = age) mode(my.list) ## [1] &quot;list&quot; mode(is.integer(pi)) ## [1] &quot;logical&quot; mode ## function (x) ## { ## if (is.expression(x)) ## return(&quot;expression&quot;) ## if (is.call(x)) ## return(switch(deparse(x[[1L]])[1L], `(` = &quot;(&quot;, &quot;call&quot;)) ## if (is.name(x)) ## &quot;name&quot; ## else switch(tx &lt;- typeof(x), double = , integer = &quot;numeric&quot;, ## closure = , builtin = , special = &quot;function&quot;, tx) ## } ## &lt;bytecode: 0x7fc5c893fc90&gt; ## &lt;environment: namespace:base&gt; Besides the mode, an object also has a length, defined as the number of elements it contains: length(age) ## [1] 3 length(names) ## [1] 3 length(my.list) ## [1] 2 The class of an object specifies its behavior and therefore its way of interacting with operations and functions. An important example are data frames: special lists whose elements all have the same length. The class of a data frame is different from that of generic lists and data frames have an indexing system that does not exist for other lists: class(my.list) ## [1] &quot;list&quot; my.data.frame = data.frame(names, age) mode(my.data.frame) ## [1] &quot;list&quot; class(my.data.frame) ## [1] &quot;data.frame&quot; my.data.frame[1,2] # to extract the 1st element from the 2nd &quot;column&quot; ## [1] 33 # Try the following command: # my.list[1,2] A special object is the missing value NA. By default, its mode is logical, howeverNA is neither TRUE norFALSE. To test if a value is missing we will use the is.na () function: NA == NA # not what we want ## [1] NA is.na(NA) ## [1] TRUE is.na(mean(c(1,4, NA))) ## [1] TRUE "],
["vectors-matrices-and-functions.html", "Chapter 4 Vectors, matrices and functions 4.1 Vectors 4.2 Matrices 4.3 Operations on numerical vectors and matrices 4.4 Factors 4.5 User-defined functions 4.6 Exercices", " Chapter 4 Vectors, matrices and functions 4.1 Vectors The R basic object is the vector (a scalar is considered as a vector of length one). The most used function to create a vector is the concatenation: price &lt;- c(150, 162, 155, 157); price ## [1] 150 162 155 157 Indexing is done through brackets: price[1] # Unlike in Python, the first index is always 1!! ## [1] 150 price[c(1.3)] ## [1] 150 price[-(1:2)] # to extract all elements except the 1st and 2nd ## [1] 155 157 One can also use a boolean indexing vector, the extracted elements are obviously those corresponding to the TRUE values. For example to extract prices greater than 156: price &gt; 156 # the boolean vector ## [1] FALSE TRUE FALSE TRUE price[price &gt; 156] ## [1] 162 157 An alternative is given by the which () function which returns the indices whose elements satisfy a logical condition: which(price &gt; 155) ## [1] 2 4 price[which(price &gt; 156)] ## [1] 162 157 You can use the indexing to change an element: price [1] &lt;- 0; price ## [1] 0 162 155 157 It is possible to give labels to the elements of a vector and extract elements based on them: names(price) ## NULL # NULL is a special object with NULL mode that reads &quot;no container&quot; names(price) &lt;- c(&#39;model.1&#39;, &#39;model.2&#39;, &#39;model.3&#39;, &#39;model.4&#39;) price ## model.1 model.2 model.3 model.4 ## 0 162 155 157 price[&#39;model.3&#39;] ## model.3 ## 155 In a vector, all the elements must have the same mode: x &lt;- c(1,2, &#39;a&#39;, &#39;b&#39;); x ## [1] &quot;1&quot; &quot;2&quot; &quot;a&quot; &quot;b&quot; mode(x) ## [1] &quot;character&quot; To generate the vector of the first \\(n\\) integers we use the syntax 1:n 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 2:6 ## [1] 2 3 4 5 6 To generate more general sequences we use the seq() function: seq(from = 2, to = 20, by = 2) # or more simply seq(2,20,2) ## [1] 2 4 6 8 10 12 14 16 18 20 We can create a vector of repeated elements with rep(): rep(1, len = 3) # same thing as rep (1,3) ## [1] 1 1 1 rep(NA, 4) ## [1] NA NA NA NA 4.2 Matrices A matrix is a vector with a dim attribute of length two. All the elements of a matrix therefore have the same mode. To create a matrix: M &lt;- matrix(2:7, nrow = 2, ncol = 3); M ## [,1] [,2] [,3] ## [1,] 2 4 6 ## [2,] 3 5 7 matrix (2:7, nrow = 2, ncol = 3, byrow = TRUE) ## [,1] [,2] [,3] ## [1,] 2 3 4 ## [2,] 5 6 7 By default matrix () fills the new matrix one column after another. Indexing is done through brackets: M[2,] # 2nd line ## [1] 3 5 7 M[, 3] # 3rd column ## [1] 6 7 M[2.3] ## [1] 3 M[3] ## [1] 4 M[, -2] # to extract all columns except the 2nd ## [,1] [,2] ## [1,] 2 6 ## [2,] 3 7 To vertically (resp. horizontally) merge two matrices we use rbind() (resp. cbind()): cbind (M, -M) ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 2 4 6 -2 -4 -6 ## [2,] 3 5 7 -3 -5 -7 rbind(M, 2 * M) ## [,1] [,2] [,3] ## [1,] 2 4 6 ## [2,] 3 5 7 ## [3,] 4 8 12 ## [4,] 6 10 14 4.3 Operations on numerical vectors and matrices Element wise operations: v &lt;- c(3,4,1,6) v + 2 ## [1] 5 6 3 8 v * 2 ## [1] 6 8 2 12 v * v ## [1] 9 16 1 36 v / 2 ## [1] 1.5 2.0 0.5 3.0 v / v ## [1] 1 1 1 1 v + v^2 ## [1] 12 20 2 42 sqrt(M) ## [,1] [,2] [,3] ## [1,] 1.414214 2.000000 2.449490 ## [2,] 1.732051 2.236068 2.645751 M * M ## [,1] [,2] [,3] ## [1,] 4 16 36 ## [2,] 9 25 49 # Try the following command: # M + v Transpose, multiplication, inverse: t(M) ## [,1] [,2] ## [1,] 2 3 ## [2,] 4 5 ## [3,] 6 7 N &lt;- M[, -3] N %*% diag(1,2) # row by column product matrix ## [,1] [,2] ## [1,] 2 4 ## [2,] 3 5 # diag (1,2) builds the 2x2 diagonal matrix where all the # diagonal elements are equal to 1, ie the 2x2 identity matrix solve(N) ## [,1] [,2] ## [1,] -2.5 2 ## [2,] 1.5 -1 solve(N) %*% N # checking if solve(N) is the inverse of N ## [,1] [,2] ## [1,] 1 1.776357e-15 ## [2,] 0 1.000000e+00 The transpose of a vector is a row matrix: V &lt;- t(v) dim(V) ## [1] 1 4 t(V) ## [,1] ## [1,] 3 ## [2,] 4 ## [3,] 1 ## [4,] 6 Pay attention to the following examples: v %*% t(v) # v is considered a column vector! ## [,1] [,2] [,3] [,4] ## [1,] 9 12 3 18 ## [2,] 12 16 4 24 ## [3,] 3 4 1 6 ## [4,] 18 24 6 36 t(v) %*% v # ditto ## [,1] ## [1,] 62 diag(1,4) %*% v # ditto ## [,1] ## [1,] 3 ## [2,] 4 ## [3,] 1 ## [4,] 6 v %*% v # v is both considered a row-vector and a column-vector ## [,1] ## [1,] 62 4.4 Factors A factor is a vector used to represent qualitative variables, ie a variable with discrete values. Its values, or categories, are called the levels in R. city &lt;- c(&#39;paris&#39;, &#39;lyon&#39;, &#39;lyon&#39;, &#39;paris&#39;, &#39;nantes&#39;) fact.city &lt;- as.factor(city); fact.city ## [1] paris lyon lyon paris nantes ## Levels: lyon nantes paris class(fact.city) ## [1] &quot;factor&quot; levels(fact.city) ## [1] &quot;lyon&quot; &quot;nantes&quot; &quot;paris&quot; A factor has the numeric mode. The reason for this counter-intuitive fact is that the elements of a factor are represented as integers corresponding to the lexicographic order of their values: mode(fact.city) ## [1] &quot;numeric&quot; as.numeric(fact.city) ## [1] 3 1 1 3 2 4.5 User-defined functions Example: my.function &lt;- function(x, y = 10) {# the default value of y is 10 z = x-y return(z) } my.function(2) ## [1] -8 my.function(2,4) ## [1] -2 my.function(y = 1, x = 4) ## [1] 3 Any variable defined in a function is local and does not appear in the workspace: try to run z 4.6 Exercices "],
["lists-and-data-frames.html", "Chapter 5 Lists and data frames 5.1 Lists 5.2 Data frames 5.3 Importing and exporting data 5.4 Exercice", " Chapter 5 Lists and data frames 5.1 Lists Lists are special vectors that can store elements of any mode (including other lists). age = c(33,28, 33) names &lt;- c(&#39;Daniel&#39;, &#39;Jehanne&#39;, &#39;Romain&#39;) my.list &lt;- list(Names = names, Age = age) Like any other vector, a list is indexed by the [...] operator, however, note that the result will be a list containing as unique element the desired item: my.list[1] ## $Names ## [1] &quot;Daniel&quot; &quot;Jehanne&quot; &quot;Romain&quot; mode(my.list[1]) ## [1] &quot;list&quot; To get the desired item directly, we therefore use the [[...]] operator or the $ operator followed by the name of the element (if available): my.list[[1]] ## [1] &quot;Daniel&quot; &quot;Jehanne&quot; &quot;Romain&quot; my.list$age ## NULL The elements of a list can have different lengths: city &lt;- c(&#39;paris&#39;, &#39;lyon&#39;, &#39;lyon&#39;, &#39;paris&#39;, &#39;nantes&#39;) my.list$city &lt;- city my.list ## $Names ## [1] &quot;Daniel&quot; &quot;Jehanne&quot; &quot;Romain&quot; ## ## $Age ## [1] 33 28 33 ## ## $city ## [1] &quot;paris&quot; &quot;lyon&quot; &quot;lyon&quot; &quot;paris&quot; &quot;nantes&quot; 5.2 Data frames The most widely data containers is the data frame, a special list of class data.frame in which all elements have the same length. For this reason, a data frame is represented in the form of a two-dimensional array whose columns are its elements. Typically, in a data frame the columns represent the variables and the rows the observations. Unlike matrices, the elements of a data frame can have different modes. id &lt;- c(&#39;id.453&#39;, &#39;id.452&#39;, &#39;id.455&#39;, &#39;id.459&#39;, &#39;id.458&#39;, &#39;id.456&#39;, &#39;id.450&#39;, &#39;id. 451&#39;) age &lt;- c (19, 45, 67, 53, 17, 30, 27, 35) smoker &lt;- c (TRUE, FALSE, TRUE, TRUE, FALSE, TRUE, TRUE, TRUE) sex &lt;- c (&#39;f&#39;, &#39;f&#39;, &#39;h&#39;, &#39;h&#39;, &#39;f&#39;, &#39;h&#39;, &#39;f&#39;, &#39;f&#39;) my.db &lt;- data.frame (Id = id, Age = age, Smoker = smoker, Sex = sex); my.db ## Id Age Smoker Sex ## 1 id.453 19 TRUE f ## 2 id.452 45 FALSE f ## 3 id.455 67 TRUE h ## 4 id.459 53 TRUE h ## 5 id.458 17 FALSE f ## 6 id.456 30 TRUE h ## 7 id.450 27 TRUE f ## 8 id. 451 35 TRUE f dim(my.db); nrow(my.db); ncol(my.db) ## [1] 8 4 ## [1] 8 ## [1] 4 names(my.db) ## [1] &quot;Id&quot; &quot;Age&quot; &quot;Smoker&quot; &quot;Sex&quot; A data frame being a list, we can extract a column using the $ operator preceded by the name of the data frame and followed by the name of the column (or variable), or use the operator [...] my.db$Sex # a column of characters is automatically transformed into a factor ## [1] f f h h f h f f ## Levels: f h my.db[, 2] ## [1] 19 45 67 53 17 30 27 35 my.db$Age[my.db$Smoker == FALSE] # simple example of selection ## [1] 45 17 The columns are directly accessible in the workspace (without having to type the name of the data frame and the $) after having attached the data frame: attach(my.db) Age ## [1] 19 45 67 53 17 30 27 35 To display only the first six lines: head(my.db) ## Id Age Smoker Sex ## 1 id.453 19 TRUE f ## 2 id.452 45 FALSE f ## 3 id.455 67 TRUE h ## 4 id.459 53 TRUE h ## 5 id.458 17 FALSE f ## 6 id.456 30 TRUE h Similarly, tail() creates a data frame with the last six columns. 5.3 Importing and exporting data Importing data is a fundamental step in data analysis. To load the data stored in a file (texte, .csv, Excel, …) into the workspace (ie into memory), you can use the basic function read.table(). The three most important arguments are: file: name (and path) of the file, in quotes header: are the elements of the first row the names of the columns? sep: character separating the columns read.table() returns a data frame: url1 &lt;- &#39;https://raw.githubusercontent.com/vittorioperduca/Introduction-to-R/master/data/iris.txt&#39; d1 &lt;- read.table(url1, # the first line contains the name of the variables header = TRUE, # values are separated by ; sep = &#39;;&#39;) head (d1) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa url2 &lt;- &#39;https://raw.githubusercontent.com/vittorioperduca/Introduction-to-R/master/data/heart.txt&#39; d2 &lt;- read.table(url2, header = TRUE, # variables are separated by a tabulation sep = &#39;\\t&#39;) dim(d2); names(d2) ## [1] 270 13 ## [1] &quot;age&quot; &quot;sexe&quot; &quot;type_douleur&quot; &quot;pression&quot; &quot;cholester&quot; ## [6] &quot;sucre&quot; &quot;electro&quot; &quot;taux_max&quot; &quot;angine&quot; &quot;depression&quot; ## [11] &quot;pic&quot; &quot;vaisseau&quot; &quot;coeur&quot; For data stored in the .Rda or .Rdata format, the import is done with load() with the argument file = filename. For instance download the Iris.Rda file at github.com/vittorioperduca/Introduction-to-R/blob/master/data/Iris.Rda to your working directory and then try the following: iris_path &lt;- &#39;data/Iris.Rda&#39; # replace with the file path load(iris_path) If you want to load .Rda or .Rdata files directly from an url, don’t forget to use the url() function (this was not necessary in read.table()). Data can be exported either to a text file (or .csv, Excel …) using write.file() or to .rda and .Rdata files at using save(). In both cases, the two main arguments are x = data to save file = the name of the file (in quotes). If the dataset is stored (or must be saved up) locally, it is necessary to know (and be able to modify) the working directory: # getwd() # try on your machine! # setwd(&#39;~/Documents&#39;) # to move to the Documents directory Remember that in Linux and macOS machines, ~/ is a shortcut for /Users/username. For Windows machines, the address syntax is slightly different. For example we use \\ instead of /. 5.4 Exercice Download the text file raw.githubusercontent.com/vittorioperduca/Introduction-to-R/master/data/hepatitis.txt to your working directory. Import the dataset in R. Warning: missing data were coded with a ?, read the documentation of read.table (). Find the number of observations, display the names of the variables and the first six observations. Check that the value of STEROID for the fourth observation is missing using the appropriate function. Calculate the mean value of ALBUMIN in women and men. Create a variable NSYMP counting the number of times a variable is equal toyes between FATIGUE andMALAISE. Pay attention to the format of these two variables! "],
["descriptive-statistics.html", "Chapter 6 Descriptive statistics 6.1 Data used 6.2 Univariate analysis 6.3 Bivariate analysis", " Chapter 6 Descriptive statistics 6.1 Data used Basic functions for graphics and descriptive statistics will be illustrated using the mtcars dataset available in R. For a description of this dataset, see the help: ?mtcars. We can also get an idea of the class and content of mtcars with str(): str(mtcars) ## &#39;data.frame&#39;: 32 obs. of 11 variables: ## $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... ## $ cyl : num 6 6 4 6 8 6 8 4 4 6 ... ## $ disp: num 160 160 108 258 360 ... ## $ hp : num 110 110 93 110 175 105 245 62 95 123 ... ## $ drat: num 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... ## $ wt : num 2.62 2.88 2.32 3.21 3.44 ... ## $ qsec: num 16.5 17 18.6 19.4 17 ... ## $ vs : num 0 0 1 1 0 1 0 1 1 1 ... ## $ am : num 1 1 1 0 0 0 0 0 0 0 ... ## $ gear: num 4 4 4 3 3 3 3 4 4 4 ... ## $ carb: num 4 4 1 1 2 1 4 2 2 4 ... The variable cyl represents the number of cylinders with three possible modalities (4, 6 or 8), so it is natural to convert it into a factor: mtcars$cyl.factor &lt;- as.factor (mtcars $ cyl) attach (mtcars) 6.2 Univariate analysis 6.2.1 Quantitative variables For a quantitative variable, the basic statistics that can be calculated are the minimum, the maximum, the mean, the variance and the standard deviation, the median and the other quantiles (remember that the quantile of order \\(p\\) is the value \\(q\\) such that \\(p\\) is the proportion of observed values less than \\(q\\)). Try the following commands min(mpg) max(mpg) range(mpg) mean(mpg) var(mpg) sd(mpg) median(mpg) quantile(mpg) quantile(mpg, probs = 0.99) # for the 99th percentile quantile(mpg, probs = c(0.01, 0.1, 0.9, 0.99)) If the input vector contains missing data, we can exclude them from the statistic calculation using the option na.rm = TRUE. The generic summary() function allows to quickly describe the distribution of a sample: summary(mpg) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 10.40 15.43 19.20 20.09 22.80 33.90 An useful tool to show a sample distribution is the boxplot: boxplot(mpg) We recall that in a boxplot: The height (or length if we choose the option horizontal = TRUE) of the box is defined by the first and third quartiles \\(q_1\\) and \\(q_3\\). The horizontal segment corresponds to the median \\(m = q_2\\). The whisker at the bottom starts from \\(q_1\\) and goes down to the minimum of the sample if there are no extreme points on the left, ie values less than \\(q_1-1.5\\times (q_3-q_1)\\). If there are extreme points on the left, the whisker stops precisely at the smallest point greater than the threshold \\(q_1-1.5\\times (q_3-q_1)\\). In this case, we place the extreme points below the whisker. Similarly, the whisker at the top starts from \\(q_3\\) and goes up to the maximum of the sample if there are no extreme points on the right, ie values greater than \\(q_3+1.5 \\times(q_3-q_1)\\). If there are extreme points on the right, the whisker stops at the greatest point less than the threshold \\(q_3+1.5\\times (q_3-q_1)\\), and we place the extreme points above of it. Try the following: u &lt;- c(mpg, 3.5, 2.7) # adding two very low values boxplot(u) q1 &lt;- quantile(u, .25); q3 &lt;- quantile(u, .75) abline(h = median(u), col = 2, lwd = 2) abline(h = q1, col = 2, lwd = 2); abline(h = q3, col = 2, lwd = 2) abline(h = max(u), col = 3, lwd = 2) # u[u &lt; q1-1.5*(q3-q1)] # extreme points on the left abline(h = min(u[u &gt;= q1-1.5*(q3-q1)]), col = 3, lwd = 2) abline(h = min(u), col = 4, lwd = 2) The other graphical tool to represent the distribution of a quantitative variable is the histogram: hist(mpg) # Try the following: # hist (mtcars$mpg, breaks = 20) # if we want 20 + 1 intervals # we specify by hand the points which define the intervals: # hist (mtcars$mpg, breaks = c (10, 15, 18, 20, 22, 25, 35)) By default the vertical axis gives the number of observations in each interval. If we want to plot the histogram in the density scale, we have to use the option freq = FALSE. In this case we recall that the proportion of observations in each interval is given by the area of the corresponding rectangle: hist(mpg, freq = FALSE) # relative frequency of observations in the [10,15] range: # the area of the first rectangle is # mean(10 &lt;= mpg &amp; mpg &lt;= 15) # to verify this, we divide the area by the base length and show # that this is precisely the height of the rectangle: abline(h = mean(10 &lt;= mpg &amp; mpg &lt;= 15)/5, col = 2) We can also compare the distribution of the sample with the theoretical distribution of the standard normal distribution through a QQ-plot. This plot compare the empircal quantiles of the sample with the theoretical quantiles of the standard normal, if the observations in the sample were normally distributed than the points in the QQ-plot should be aligned along the bisector: qqnorm(mpg) qqline(mpg) # the line sample quantiles = theoretical quantiles Remark. Compare the previous QQ-plot to that of the standardized sample: mpg.stand &lt;- (mpg-mean(mpg))/sd(mpg) # we standardize mpg qqnorm(mpg.stand); qqline(mpg.stand) What happened? Note that the distribution of quantiles did not change: hist(quantile(mpg)) hist(quantile(mpg.stand)) 6.2.2 Qualitative variables The summary() and table() functions applied to a factor (or a vector of characters) count the occurrences of the different levels. summary(cyl.factor) ## 4 6 8 ## 11 7 14 table(cyl.factor) ## cyl.factor ## 4 6 8 ## 11 7 14 To get the proportions: prop.table(table (cyl.factor)) ## cyl.factor ## 4 6 8 ## 0.34375 0.21875 0.43750 If there are missing values, summary () also counts the NA: x &lt;- as.factor(c(&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, NA, &#39;c&#39;)) summary(x) ## a b c NA&#39;s ## 2 1 2 1 table(x) ## x ## a b c ## 2 1 2 prop.table(table(x)) # counts are divided by the total number of non-missing values ## x ## a b c ## 0.4 0.2 0.4 prop.table(summary(x)) # counts are divided by the total number of values ## a b c NA&#39;s ## 0.3333333 0.1666667 0.3333333 0.1666667 We can use a bar plot or a pie chart (not recommended) to represent occurrences: barplot(table(cyl.factor)) pie(summary(cyl.factor)) 6.3 Bivariate analysis 6.3.1 Quantitative variable vs quantitative variable We consider two quantitative variables measured on the same individuals. For two quantitative variables, we can compute their covariance and linear correlation: the covariance measures the average joint deviation from the means of the two variables Pearson’s linear correlation coefficient \\(\\rho\\) measures the intensity of linear dependence. \\(\\rho\\) is comprised between \\(-1\\) and \\(1\\): its value is close to \\(1\\) (resp. \\(-1\\)) if there is a positive (resp. negative) linear dependence while its value is close to \\(0\\) if there is no linear dependence. cov(mpg, wt) cor(mpg, wt) # Try this: # cov(mpg, wt)/sd(mpg)/sd(wt) Another type of correlation is Spearman’s correlation measuring the linear correlation between the ranks of the values of the two variables: cor(mpg, wt, method = &#39;spearman&#39;) # Try this # cor(rank(mpg), rank(wt)) To graphically represent two quantitative variables we will use a a scatter plot: plot(x = wt, y = mpg) # x, y = coordinates of the points # Alternative: # plot (wt ~ mpg) # where the ~ reads &quot;wt according to mpg&quot; To find the least squares line (ie the linear model that best fits the data) and add it to the data: m &lt;- lm(mpg ~ wt) summary(m) ## ## Call: ## lm(formula = mpg ~ wt) ## ## Residuals: ## Min 1Q Median 3Q Max ## -4.5432 -2.3647 -0.1252 1.4096 6.8727 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 37.2851 1.8776 19.858 &lt; 2e-16 *** ## wt -5.3445 0.5591 -9.559 1.29e-10 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 3.046 on 30 degrees of freedom ## Multiple R-squared: 0.7528, Adjusted R-squared: 0.7446 ## F-statistic: 91.38 on 1 and 30 DF, p-value: 1.294e-10 # try: # slope &lt;- sum ((wt-mean(wt)) * (mpg-mean(mpg))) / sum((wt-mean (wt))^2) # intercept &lt;- mean (mpg) - slope * mean (wt) plot(mpg ~ wt) abline(m, col = &quot;red&quot;) 6.3.2 3.2 Qualitative variable vs qualitative variable We consider two qualitative variables measured on the same individuals. For these variables, we can make contingency tables and calculate the total and marginal relative frequencies (in rows and columns). Try the following: t &lt;- table(cyl, am) # cyl and am are digital vectors, # but to build the contingency table # table() counts their terms. t prop.table(t) # Prob(cyl, am) prop.table(t, margin = 1) # P(am | cyl = 4), P(am | cyl = 6), P(am | cyl = 8) prop.table(t, margin = 2) # P(cyl | am = 0), P(cyl | am = 1) The corresponding graphic is the mosaic plot: par(mfrow = c (1,2)) # to put two charts side by side mosaicplot(table(cyl, am)) # P(am | cyl = 4), P(am | cyl = 6), P(am | cyl = 8) mosaicplot(table(am, cyl)) # P(cyl | am = 0), P(cyl | am = 1) 6.3.3 Quantitative variable vs qualitative variable To evaluate a function f on the values of a y for each level of a factor x we usetapply (X = y, INDEX = x, FUN = f). This is very useful when we want to calculate the statistics of a quantitative variable y grouped according to the levels of a qualitative variablex. To see this, try the following: tapply(mtcars$mpg, mtcars$cyl, mean) # the average miles per gallon according to the number of cylinders tapply(mtcars$mpg, mtcars$cyl, summary) Graphically, we can build the boxplot of the quantitative variable for each level of qualitative variable: boxplot(mpg ~ cyl, data = mtcars) "],
["base-graphics.html", "Chapter 7 Base graphics 7.1 Basic constructions and scatter plots 7.2 Line graphs 7.3 Graphical parameters 7.4 Histograms 7.5 Exercises", " Chapter 7 Base graphics 7.1 Basic constructions and scatter plots We have already seen how to add a line to a scatter plot, to complete the graph we can specify a title, change the axis labels, and add a legend: plot(wt, mpg, main = &#39;Weight and consumption of cars&#39;, xlab = &#39;weight&#39;, ylab = &#39;consumption&#39;) # xlab = label x axis abline(h = mean (mpg), col = 2, lty = 2) # h = horizontal line, col = color, lty = line type legend(x = &#39;topright&#39;, lty = 2, col = 2, legend = &#39;average consumption&#39;) # x = legend location We can also add a third dimension by coloring the points according to a condition: plot(wt, mpg, pch = 19, # pch = type of point col = (mpg &gt;= mean (mpg)) + 1 # 1 = black, 2 = red ) abline(h = mean(mpg), col = 2, lty = 2) # h = horizontal line, col = color, lty = line type legend(x = &#39;topright&#39;, pch = 19, col = 2: 1, legend = c (&#39;cons&gt; = average&#39;, &#39;cons &lt;average&#39;), # legend = vector with labels bty = &#39;n&#39; # no frame around the legend ) In general, abline(a, b) allows to add a line with intercept a and slopeb to an existing plot. For example, an alternative way to add the regression line is as follows: intercept = coef(m)[1] slope = coef(m)[2] plot(wt, mpg, main = &#39;Line of least squares&#39;) abline(a = intercept, b = slope) To add any line (not necessarily a straight line) we use the lines() function. For example, to add the lowess (locally-weighted polynomial regression) smoothing curve: plot(wt, mpg, main = &#39;Smoothing curve&#39;) lines(lowess (mpg ~ wt), # lines (): to add a curve col = &#39;blue&#39;, # same as col = 4 lwd = 2) # lwd = line thickness We can add new points using points(): plot(wt, mpg, main = &#39;Smoothing curves&#39;) lines(lowess (mpg ~ wt), col = &#39;blue&#39;, lwd = 2) outliers = cbind(c(4.5,4.6,5), c(26,26,30)) points(outliers, pch = 2) # pch = 2 for triangles lines(lowess (c (wt, outliers[, 1]), c (mpg, outliers[, 2])), col = 2, lwd = 2) legend (x = &#39;bottomleft&#39;, col = c (4,2), lwd = 2, legend = c (&#39;without outliers&#39;, &#39;with outliers&#39;), bty = &#39;n&#39;) We can control the range of axes using xlim() and ylim(): plot(wt, mpg, main = &#39;Same data with different scale&#39;, xlim = c (0, 25), ylim = c (0, 100)) 7.2 Line graphs The lines() function adds a line to an existing graph and cannot be used to create a new graph. To draw a line connecting the successive elements of a vector we will rather use plot(x = vector, type = l): mydata = cos(2 * pi / 12 * (1:36)) + rnorm (36,0, .2) # data simulation plot(mydata, type = &#39;l&#39;, main = &#39;type = l&#39;) The type parameter allows you to connect (or not) the points in different ways: par(mfrow = c (2,2)) # explained in the next section plot(mydata, type = &#39;p&#39;, main = &#39;type = p&#39;) # default plot(mydata, type = &#39;o&#39;, main = &#39;type = o&#39;) plot(1: 10, type = &#39;S&#39;, main = &#39;type = S&#39;) # steps 1 plot(1: 10, type = &#39;s&#39;, main = &#39;type = s&#39;) # steps 2 With plot = 'h' we get a bar plot: plot (1: 10, type = &#39;h&#39;, main = &#39;type = h&#39;) 7.3 Graphical parameters We have already seen that it is possible to control certain graphical elements using parameters: Element Parameter point pch type of line graph type color col line lty,lwd axis label xlab,ylab axis dimensions xlim,ylim label dimensions cex orientation axes labels las See ?par for a description of the values that these parameters can take. To impose parameters on all the graphics produced during a session, we will use the par() function. par() is often used to view two or more plots in the same window with the parameter mfrow = c(l, c). In this case the graphs are displayed in a grid with l rows and c columns. Try the following: # opar = par () # to be able to reset with the initial parameters par(mfrow = c (1,2)) plot(wt, mpg, main = &#39;Weight, consumption&#39;) boxplot(hp, main = &#39;Power&#39;) Changes are implemented until when the session is closed, or the graphics engine is reset by dev.off() or by clicking on the Clear all plots brush in RStudio. par() is also used to change the size of the margins. This is sometimes useful when the labels on the axes do not fit in the window, as in this example: mydata = as.factor(sample (x = c (&#39;Paris&#39;, &#39;London&#39;, &#39;Brussels&#39;, &#39;Washington&#39;), replace = T, prob = c (.1, .5, .2, .1), size = 100)) # simulation of a qualitative variable barplot(summary (mydata), width = .1, horiz = T, las = 2) We modify the parameter which sets the left margin: par(mar = c(5, 6, 4, 2) + 0.1) # the second component of mar gives the left margin # Default is c (5, 4, 4, 2) + 0.1 barplot(summary (mydata), width = .1, horiz = T, las = 2) 7.4 Histograms As we have already noted in the subsection 6.2.1, by default, hist() displays the histogram with the counts. To display the histogram in the density scale we use the option freq = FALSE. In this case, the area of each rectangle will be equal to the proportion of observations in the corresponding class (so that the total area of all the rectangles is one). par(mfrow = c (1,2)) hist(mpg) # freq = TRUE hist(mpg, freq = FALSE) To superimpose the curve of a given density: mydata = rnorm (1000,0,1) # simulation of 1000 observations N (0,1) hist(mydata, freq = F, main = &#39;Histogram and theoretical density&#39;) curve(dnorm, # the density function of N (0,1) from = -5, to = 5, # the range add = TRUE) # because we want to add the density of N (0,1) to the histogram Rather than viewing the histogram of the data, we can show the estimated density (using kernel density estimation methods): hist(mpg, freq = F, main = &#39;Histogram and estimated density&#39;) lines(density (mpg), col = 2) 7.5 Exercises We consider the midwest dataset from the ggplot2 package (an advanced graphics package). Install and charge the package. Consult the help for the description of the variables in midwest. Reproduce the following graphics using basic functions: We consider the adult dataset available on the site archive.ics.uci.edu/ml/datasets/Adult. The dataset consists of 48,842 rows and 14 columns. Import the data into R from the file adult.data. Look in the adult.names file for the names of the variables. Describe each variable appropriately according to its type. Describe the relationship between the variables age andclass. "]
]
